
    \section*{Correcteur Orthographique}
    
    \subsection*{Conception préliminaire}
    \textbf{Type} CorrecteurOrthographique = Structure
	\begin{itemize}[label=$\ $, leftmargin=2cm]
		 \item motACorriger : Mot
		 \item leDictionnaire : Naturel
		 \item lesCorrections : EnsembleDeMot
	\end{itemize}
    finStructure
    \subsubsection*{Signatures}

	\begin{itemize}[label=$\ $, leftmargin=1cm]
		 
		 \item \textbf{fonction} correcteur(unDico : Dictionnaire, unMotFaux : Mot): CorrecteurOrthographique
		 \begin{itemize}[label=$| $]
            \item \textbf{précondition:} non(Dictionnaire.estUnMotDuDictionnaire(unDico, unMotFaux))
         \end{itemize}
		 \item \textbf{fonction} obtenirMotACorriger(unCorrecteur : CorrecteurOrthographique) : Mot
		 \item \textbf{fonction} obtenirDictionnaire(unCorrecteur : CorrecteurOrthographique) : Dictionnaire
		 \item \textbf{procedure} fixerDico(\textbf{E/S} unCorrecteur : CorrecteurOrthographique,\textbf{E} unDico : Dictionnaire) 
		 \item \textbf{procedure} fixerMotACorriger(\textbf{E/S} unCorrecteur : CorrecteurOrthographique,\textbf{E} unMotFaux : Mot)
		 \begin{itemize}[label=$| $]
            \item \textbf{précondition:} non(Dictionnaire.estUnMotDuDictionnaire(obtenirDictionnaire(unCorrecteur), unMotFaux))
         \end{itemize}
		 \item \textbf{procedure} ajouterNouvellesCorrections(\textbf{E/S} unCorrecteur : CorrecteurOrthographique,\textbf{E} desCorrections : EnsembleDeMot)
		 \item \textbf{procedure} trouverCorrectionsPossibles(\textbf{E/S} unCorrecteur : CorrecteurOrthographique)
		 \item \textbf{fonction} remplacerIemeLettreEnBoucle(unMot : Mot, indice : Naturel) : EnsembleDeMot
		 \item \textbf{procedure} strategieRemplacerLettres(\textbf{E/S} unCorrecteur : CorrecteurOrthographique)
		 \item \textbf{procedure} strategieSupprimerLettres(\textbf{E/S} unCorrecteur : CorrecteurOrthographique)
		 \item \textbf{procedure} strategieInverserDeuxLettresConsecutives(\textbf{E/S} unCorrecteur : CorrecteurOrthographique)
		 \item \textbf{fonction} insererIemeLettreEnBoucle(unMot : Mot, indice : Naturel) : EnsembleDeMot
		 \item \textbf{procedure} strategieInsererLettres(\textbf{E/S} unCorrecteur : CorrecteurOrthographique)
		 \item \textbf{procedure} strategieDecomposerMot(\textbf{E/S} unCorrecteur : CorrecteurOrthographique)
		 \item \textbf{procedure} supprimerCorrecteur(\textbf{E} unCorrecteur : CorrecteurOrthographique)
		 
		 
         
         
        
	\end{itemize} 
    
    \subsection*{Conception détaillée}

    \begin{function}
    \SetAlgoLined
    \caption{remplacerIemeLettreEnBoucle(\textbf{E/S} mot : Mot, \textbf{E} position : naturel)}
    \Declaration{desCorrections : EnsembleDeMot, uneCorrection : Mot, lettres : chaine de caracteres}
    \Deb{
        desCorrections=EnsembleDeMot.ensembleDeMot()
        lettres = "abcdefghijklmnopqrstuvwxyzàéèëùûêîïçôö-"
        \Pour{j $\gets$ 0 à longueur(lettres)}{
        	uneCorrection $\gets$ Mot.copierMot(mot)
            Mot.fixierIemeCaractere(uneCorrection,i,lettres[j])
            EnsembleDeMot.ajouter(desCorrections,uneCorrection)
        	insererLettre(mot2, i, c);
        }
        \Retour{desCorrections}
    }
    \end{function}

    
    
    \begin{procedure}
    \SetAlgoLined
    \caption{supprimerIemeLettre(\textbf{E/S} unMot, \textbf{E} position : Naturel)}
    \Pre{longueur(mot)$\ge$1 et i$\le$longueur}\\
    \Declaration{}
    \Deb{
       ChaineDeCaractere.supprimerIemeLettre(unMot.chaine,position)\;
       unMot.longueur $\gets$ unMot.longueur-1 \;
    }
    \end{procedure}
    
    \begin{procedure}
    \SetAlgoLined
    \caption{inverserDeuxLettresConsecutives(\textbf{E/S} unMot : Mot, \textbf{E} i : NaturelNonNul)}
    \Pre{longueur(mot)$\ge$1 et i$\le$longueur}\\
    \Declaration{c1,c2 : Caractere}
    \Deb{
    	c1 $\gets$ Mot.accederAuIemeCaractere(unMot,i)\;
    	c2 $\gets$ Mot.accederAuIemeCaractere(unMot,i+1)\;
    	remplacerIemeLettre(unMot, c2, i)\;
    	remplacerIemeLettre(unMot, c1, i+1)\;
    }
    \end{procedure}
    
     \begin{procedure}
    \SetAlgoLined
    \caption{insererLettre(\textbf{E/S} unMot : Mot, \textbf{E} position : Naturel, c : Caractere)}
    \Pre{i$\le$ longueur(mot)}\\
    \Declaration{}
    \Deb{
       ChaineDeCaratere.insererLettre(unMot.chaine,position,c)\;
       unMot.longueur $\gets$ unMot.longueur + 1\;
    }
    \end{procedure}
    
    \begin{function}
    \SetAlgoLined
    \caption{decomposerMot(unMot : Mot, position : NaturelNonNul) : Mot, Mot}
    \Pre{i$\le$ longueur(mot)}\\
    \Declaration{mot1, mot2 : Mot, c : Caractere, chaine1, chaine2 : ChaineDeCaractere}
    \Deb{
    	mot1 $\gets$ creerUnMot("")\;
    	mot2 $\gets$ creerUnMot("")\;
       \Pour{i $\gets$ 1 à position-1}{
        	c $\gets$ Mot.accederAuIemeCaractere(unMot,i)\;
        	insererLettre(mot1, i, c);
        }
        \Pour{i $\gets$ position à unMot.longueur}{
        	c $\gets$ Mot.accederAuIemeCaractere(unMot,i)\;
        	insererLettre(mot2, i, c);
        }
      	\Retour{mot1, mot2}
    }
    \end{function}
 
<<<<<<< HEAD
=======
\end{document}
>>>>>>> 2f736bb8c6940cb047a51d3eb5e33c1304e1dcfa
