\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{enumitem}
\usepackage{amssymb}
\usepackage{times}
\usepackage{fancyhdr,graphicx,amsmath,amssymb}
\usepackage[ruled,vlined, french]{algorithm2e}
    \SetKwInput{Declaration}{Declaration}
    \SetKw{KwA}{a}
    \SetKw{Retour}{retourner}
    \SetKwBlock{Deb}{debut}{fin}
    \SetKwIF{Si}{SinonSi}{Sinon}{si}{alors}{sinon si}{sinon}{finsi}
    \SetKwFor{Tq}{tant que}{faire}{finTantQue}
    \SetKwFor{Pour}{pour}{faire}{finPour}
    \SetKwRepeat{Repeter}{repeter}{jusqu’a}
    \SetKw{Pre}{Precondition(s)}
    \SetKwFor{PourCh}{pour chaque}{faire}{finprch}
\usepackage[hmargin=2cm,vmargin=0cm]{geometry}

\begin{document}
    \pagestyle{empty}
    \noindent

    \section*{Mot}
    \subsection*{Conception préliminaire}

    \textbf{Type} Mot = Structure
	\begin{itemize}[label=$\ $, leftmargin=2cm]
		 \item ch : ChaineDeCaractere
		 \item long : Naturel
	\end{itemize}
    finStructure
    
    \subsubsection*{Signatures}

	\begin{itemize}[label=$\ $, leftmargin=1cm]
		 \item \textbf{fonction} estUnMotValide(uneChaine : Chaine de Caractère) :Booleen
		 \item \textbf{fonction} creerUnMot(uneChaine : Chaine de Caractère) : Mot
		 \item \textbf{fonction} longueur(unMot : Mot) : Naturel
		 \item \textbf{fonction} accederAuIemeCaractere(unMot : Mot, position : NaturelNonNul) : Caractere
		 \begin{itemize}[label=$| $]
            \item \textbf{précondition:} position $<$ longueur(unMot)
         \end{itemize}
         \item \textbf{fonction} sontEgaux(unMot, unAutreMot : Mot) : Booleen
         \item \textbf{procedure} fixerIemeCaractere(\textbf{E/S} unMot : Mot, \textbf{E} position : NaturelNonNul, c : Caractere)
         \item \textbf{procedure} fixerLongueur(\textbf{E/S} unMot : Mot, \textbf{E} longueur : Naturel)
	\end{itemize} 

    \subsection*{Conception détaillée}

    \begin{function}
        \SetAlgoLined
        \caption{estUnMotValide(chaine : Chaine de Caractere):Booleen}
        \Declaration{valide : Booleen}
        \Deb{
            estValide $\gets$ VRAI \;
            i $\gets$ 1 \;
            \Tq {(i $\le$ longueur(unMot)) et (valide)}{
                c $\gets$ accederAuIemeCaractere(unMot,i) \;
                valide $\gets$ Ensemble.estPresent(CaractereAlphabetique,c) \;
                i $\gets$ i+1 \;
            }
            \Retour{valide}
        }
    \end{function}
        
    \begin{function}
        \SetAlgoLined
        \caption{creerUnMot(chaine : Chaine de Caractere):Mot}
        \Declaration{mot : Mot}
        \Deb{
            \Si{estValide(chaine)}{
                mot.ch $ \gets $ ch \; 
                mot.long $ \gets $ ChaineDeCaractere.longueur(chaine) \;
                \Retour{mot}
            }
            \Sinon{\Retour{NULL}}
        }
   	\end{function}
    
    \begin{function}
        \SetAlgoLined
        \caption{longueur(unMot : Mot):Naturel}
        \Declaration{}
        \Deb{
            \Retour{unMot.long}
        }
    \end{function}
        
    \begin{function}
        \SetAlgoLined
        \caption{accederAuIemeCaractere(unMot : Mot, position :NaturelNonNul):Caractere}
        \Pre{position $\le$ longueur(unMot)}
        \Declaration{}
        \Deb{
            \Retour{ChaineDeCaractere.iemeCaractere(unMot.ch,position)}
        }
    \end{function}
    
    \begin{function}
        \SetAlgoLined
        \caption{sontEgaux(unMot,unAutreMot : Mot):Booleen}
        \Declaration{
            i : Naturel \;
            egaux : Booleen \;}
        \Deb{
            \Si {longueur(unMot) $\ne$ longueur(unAutreMot)}{
                \Retour{FAUX}
            }
            \Sinon{
                egaux $\gets$ VRAI \;
                i $\gets$ 1 \;
                \Tq {(i $\le$ longueur(unMot)) et (egaux)}{
                    egaux $\gets$ accederAuIemeCaractere(unMot,i) = accederAuIemeCaractere(unAutreMot,i) \;
                    i $\gets$ i+1 \;
                }
                \Retour{egaux}
            }
        }
        
    \end{function} 
    
\end{document}
